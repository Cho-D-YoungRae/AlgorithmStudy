# [자물쇠와 열쇠](https://programmers.co.kr/learn/courses/30/lessons/60059)

## Skills

- 배열을 다른 배열에 겹쳐볼 때는 아래와 오른쪽만 생각하지 말고 위와 왼쪽까지 사방을 다 생각하자
- 배열의 크기를 넓혀서 해결해보기

## My Solution 2 - -> Wrong

> 2022/12/13

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    public boolean solution(int[][] key, int[][] lock) {
        List<int[][]> keys = new ArrayList<>();
        keys.add(key);
        for (int i = 0; i < 3; i++) {
            keys.add(rotateArr(keys.get(keys.size() - 1)));
        }

        for (int i = 0; i < lock.length; i++) {
            for (int j = 0; j < lock[0].length; j++) {
                for (int[][] rotatedKey : keys) {
                    if (canUnlock(rotatedKey, lock, i, j)) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    private int[][] rotateArr(int[][] origin) {
        int[][] result = new int[origin[0].length][origin.length];
        for (int i = 0; i < result.length; i++) {
            for (int j = 0; j < result[0].length; j++) {
                result[i][j] = origin[origin.length - j - 1][i];
            }
        }
        return result;
    }

    private boolean canUnlock(int[][] key, int[][] lock, int startI, int startJ) {
        int[][] unlock = new int[lock.length][lock[0].length];

        for (int i = 0; i < unlock.length; i++) {
            for (int j = 0; j < unlock[0].length; j++) {
                unlock[i][j] = lock[i][j];
            }
        }

        int endI = Math.min(lock.length - startI, key.length);
        int endJ = Math.min(lock[0].length - startJ, key[0].length);
        for (int i = 0; i < endI; i++) {
            for (int j = 0; j < endJ; j++) {
                unlock[startI + i][startJ + j] = lock[startI + i][startJ + j] + key[i][j];
            }
        }

        for (int i = 0; i < unlock.length; i++) {
            for (int j = 0; j < unlock[0].length; j++) {
                if (unlock[i][j] != 1) {
                    return false;
                }
            }
        }

        return true;
    }
}
```

### 오답 참고 

- <https://school.programmers.co.kr/questions/20370>

## My Solution 2 - 2

> 2022/12/13

```java

```

## My Solution 1 -> wrong

```python
def rotate_key(key):
    M = len(key)
    rotated = []
    for i in range(M):
        newrow = []
        for j in range(M):
            newrow.append(key[M-j-1][i])
        rotated.append(newrow)

    return rotated


def solution(key, lock):
    N = len(lock)
    M = len(key)

    def is_correct_key(lock_i, lock_j):
        for i in range(M):
            for j in range(M):
                if lock[lock_i+i][lock_j+j] == 0 \
                                and key[i][j] == 0:
                    return False

        return True

    for i in range(N-M+1):
        for j in range(N-M+1):
            for z in range(4):
                if is_correct_key(i, j):
                    return True
                key = rotate_key(key)


    return False
```

lock에서 key범위 밖에도 0이 있을 수 있는 데 그 부분을 확인하지 않는다.

## My Solution 1-2 -> wrong

```python
def rotate_key(key):
    M = len(key)
    rotated = []
    for i in range(M):
        newrow = []
        for j in range(M):
            newrow.append(key[M-j-1][i])
        rotated.append(newrow)

    return rotated


def solution(key, lock):
    N, M = len(lock), len(key)

    def is_correct_key(lock_i, lock_j):
        for i in range(N):
            for j in range(N):
                if lock[i][j] == 0:
                    if lock_i <= i < lock_i + M and lock_j <= j < lock_j + M:
                        if key[i - lock_i][j - lock_j] == 0:
                            return False
                    else:
                        return False
        return True

    for i in range(N - M + 1):
        for j in range(N - M + 1):
            for z in range(4):
                if is_correct_key(i, j):
                    return True
                key = rotate_key(key)

    return False
```

**오답정리**
key의 모든 부분이 lock 안에 들어가 있지 않아도 된다. 즉, 구석 부분만 lock에 끼워져도 된다.
